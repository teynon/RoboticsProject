#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, in5,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in6,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in7,    rightLine,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  rearRightBumper, sensorTouch)
#pragma config(Sensor, dgtl2,  rearLeftBumper, sensorTouch)
#pragma config(Sensor, dgtl3,  sonarLimits,    sensorTouch)
#pragma config(Sensor, dgtl11, sonar,          sensorSONAR_cm)
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           sonarDrive,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           clawDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armDrive,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int const sonarRangeOfMotion = 100;
int degreesPerSecond = 0;
int currentAngle = 0;

void move_forwards(int ms){
		//motor[rightDrive] = 63; // Motor on port2 is run at half (63) power forward
		//motor[leftDrive]  = 63;	// Motor on port3 is run at half (63) power forward
		//wait1Msec(ms)
}

void move_backwards(int ms){
		//motor[rightDrive] = -63; // Motor on port2 is run at half (63) power forward
		//motor[leftDrive]  = -63;	// Motor on port3 is run at half (63) power forward
		//wait1Msec(ms)
}

void turn_left(int ms){
		//motor[rightDrive] = 127; // Motor on port2 is run at half (63) power forward
		//motor[leftDrive]  = -127;	// Motor on port3 is run at half (63) power forward
		//wait1Msec(ms)
}

void turn_right(int ms){
		//motor[rightDrive] = -127; // Motor on port2 is run at half (63) power forward
		//motor[leftDrive]  = 127;	// Motor on port3 is run at half (63) power forward
		//wait1Msec(ms)
}

void calibrateSonar()
{
	int counter = 0;

	// Move the sonar until it hits one of the limit switches.
	while(SensorValue(sonarLimits) == 0)
	{
		motor[sonarDrive] = 30;
		wait1Msec(5);
	}

	motor[sonarDrive] = -30;	// Move in the other direction.
	wait10Msec(15);						// Let it get off the sensor.
	motor[sonarDrive] = 0;		// Stop the motor.

	// Now we are at the starting position. We need to move to the other side
	//  and record a time.
	while(SensorValue(sonarLimits))
	{
		motor[sonarDrive] = -30;		// Move the motor until it hits the opposite limit switch.
		wait1Msec(5);
		counter = counter + 5;		// Increment the counter.
	}

	motor[sonarDrive] = 0;

	degreesPerSecond = sonarRangeOfMotion / counter;
	currentAngle = 0;
}


void lookAtAngle(int angle)
{
	int direction = 30;
	int timeToMove = 0;
	
	// Get direction to move
	if (angle > currentAngle) direction *= -1;
	timeToMove = abs(angle - currentAngle) / degreesPerSecond;
	
	// Turn for X Seconds
	while (SensorValue(sonarLimits) == 0 && timeToMove > 0) {
		motor[sonarDrive] = direction;
		wait1Msec(5);
	}
	
	motor[sonarDrive] = 0;
}

void lookForward()
{
	lookAtAngle((int)(sonarRangeOfMotion / 2));
}


task main()
{

	calibrateSonar();
	lookForward();

	/*while(true)
	{
		while(SensorValue(sonarLimits) == 0)
		{
			motor[sonarDrive] = 30;
			wait1Msec(5);
		}

		while(SensorValue(sonarLimits) == 1)
		{
			motor[sonarDrive] = -30;
			wait1Msec(1);
		}

		//

		while(SensorValue(sonarLimits) == 0)
		{
			motor[sonarDrive] = -30;
			wait1Msec(1);
		}

		while(SensorValue(sonarLimits) == 1)
		{
			motor[sonarDrive] = 30;
			wait1Msec(1);
		}
	}*/

}
