#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, in6,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in7,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in8,    leftLine,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  rearRightBumper, sensorTouch)
#pragma config(Sensor, dgtl2,  rearLeftBumper, sensorTouch)
#pragma config(Sensor, dgtl3,  armLimit,       sensorTouch)
#pragma config(Sensor, dgtl7,  sonarRight,     sensorSONAR_inch)
#pragma config(Sensor, dgtl9,  sonarLeft,      sensorSONAR_inch)
#pragma config(Sensor, dgtl11, sonarFront,     sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  debugleftI2C,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  debugRightI2C,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           sonarLook,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           clawDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armDrive,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightDrive,    tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int minPower = 25;
int maxPower = 40;
int angle = 0;
int minPowerThreshold = 2;

// Drive Speeds
int motorSpeed = 100;
int minMotorSpeed = 40;
int angle90 = 615;

void checkArm() 
{	
	if(SensorValue(armLimit)) 
	{
		// Force motor up.
		motor[armDrive] = maxPower;
		wait10Msec(5);
		
		// Set armDrive to something higher.
		angle = 10;
	}
	int degrees = SensorValue(armAngle);
	
	if (degrees < angle) 
	{
		// Move motor up.
		if (degrees + minPowerThreshold < angle)
			motor[armDrive] = maxPower;
		else 
			motor[armDrive] = minPower;
	}
	else if (degrees > angle) 
	{
		// Move motor down.
		motor[armDrive] = -minPower;
	}
	else 
	{
		// Turn motor off
		motor[armDrive] = 0;
	}
}

void setArm(int degrees) 
{
	angle = degrees; //(degrees * conversion)(degrees - min) / conversion;
	checkArm();
}

void turn_left(int ms, int power) 
{
	motor[rightDrive] = -power; 	// Motor on port2 is run at half (63) power forward
	motor[leftDrive]  = power;	// Motor on port3 is run at half (63) power forward
	wait1Msec(ms);
}

void turn_right(int ms, int power) 
{
	motor[rightDrive] = power; // Motor on port2 is run at half (63) power forward
	motor[leftDrive]  = -power;	// Motor on port3 is run at half (63) power forward
	wait1Msec(ms);
}

void turn_right_angle(int angle) 
{
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	//int amount = angle * angleConversion;
	int amount = angle;
	
	while (nMotorEncoder[leftDrive] < amount && nMotorEncoder[rightDrive] > -amount) 
	{
		turn_right(1, motorSpeed / 2);
		checkArm();
	}
	
	// Reverse power shortly.
	turn_left(15, motorSpeed);
	
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}

// Call this function to have the robot travel down the hallway.
void travelHallway()
{
	// We need to keep the robot in the middle of the hallway. To do that, we will use the three sonars on our robot.
	// The front, left, and right sonars will be used.
	// Front: To determine if we have reached the end of the hall or not.
	// Left: To ensure we are the same distance away from the left wall as the right wall.
	// Right: To ensure we are the same distance away from the right wall as the left wall.
	// We will 60 for the normal speed.
	// We will use 70 for the slightly higher speed.

	int leftMotorSpeed;
	int rightMotorSpeed;

	// Set arm to be parallel with the ground.
	setArm(25);

	// Set the initial motor speeds;
	leftMotorSpeed = -80;
	rightMotorSpeed = -80;

	// Loop indefinetly. 
	while(true)
	{
		// If we are about to hit something, rotate 180 degrees.
		if(SensorValue[sonarFront] < 10 || SensorValue[sonarFront] == -1)
			turn_right_angle(angle90 * 2);
	
		// If the sonar values are the same.
		if(SensorValue[sonarLeft] == SensorValue[sonarRight])
		{
			// Set the motor speeds to the same value
			leftMotorSpeed = -30;
			rightMotorSpeed = -30;
		}
		// If the left sonar value is greater than the right sonar value, we are closer to the right wall.
		else if(SensorValue[sonarLeft] > SensorValue[sonarRight])
		{
			// Set the left motor speed slightly higher. This should let the robot drift to the left.
			leftMotorSpeed = -80;
			rightMotorSpeed = -30;
		}
		// If the right sonar value is greater than the left sonar value, we are closer to the left wall.
		else if(SensorValue[sonarRight] > SensorValue[sonarLeft])
		{
			// Set the right motor speed slightly higher. This should let the robot drift to the right.
			leftMotorSpeed = -30;
			rightMotorSpeed = -80;
		}

		// Move forward using the speed variables for each motor.
		motor[leftDrive] = leftMotorSpeed;
		motor[rightDrive] = rightMotorSpeed;
	}

	// Stop moving the robot
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}

task main()
{
	travelHallway();
}
