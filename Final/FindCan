#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, in6,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in7,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in8,    leftLine,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  rearRightBumper, sensorTouch)
#pragma config(Sensor, dgtl2,  rearLeftBumper, sensorTouch)
#pragma config(Sensor, dgtl3,  armLimit,       sensorTouch)
#pragma config(Sensor, dgtl7,  sonarRight,     sensorSONAR_inch)
#pragma config(Sensor, dgtl9,  sonarLeft,      sensorSONAR_inch)
#pragma config(Sensor, dgtl11, sonarFront,     sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  debugleftI2C,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  debugRightI2C,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           sonarLook,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           clawDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armDrive,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightDrive,    tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ===============================================
// TYPEDEF
// -----------------------------------------------
typedef struct {
	int x;
	int y;
} cell;

typedef struct {
	cell position;
	int direction;
	cell goal;
} robot;

// ------------------------------------------------
// END TYPEDEF
// ================================================


// ================================================
// GLOBALS
// ------------------------------------------------
const int gridWidth = 10;
const int gridHeight = 10;

// The robot's starting position.
int startX = 0;
int startY = 0;

// The robot's current position.
int currentX = 0;
int currentY = 0;

// The goal's position.
int goalX = 9;
int goalY = 5;

int distancePerSquare = 100;
int openCells = gridWidth * gridHeight;

bool grid[gridHeight][gridWidth];	// 
bool open[gridHeight][gridWidth];	// 
cell path[gridWidth * gridHeight];	// The path the robot will take.
int pathIndex = 0;			// The number of cells in the robots path.

const int sonarRangeOfMotion = 100;
int degreesPerSecond = 0;
int currentAngle = 0;
int angleConversion = 5;

robot Me;

// Drive Speeds
int motorSpeed = 100;
int minMotorSpeed = 40;
int angle90 = 520;
int leftConversion = -100;

const int lightThreshold = 40;

int angle = 0;
int angleROM = 90;
int min = 1300;
int max = 3400;
int conversion = (max - min) / angleROM;
int maxPower = 40;
int minPower = 25;
int minPowerThreshold = 2;
int sonarOffset = -10;
int frontDistance = 0;

// Prototype function so it can be called from other methods defined before this one is defined.
void checkArm();
void checkState();
void initOpen();
void lookAtAngle(int angle);

// ------------------------------------------------
// END GLOBALS
// ================================================

// =================================================
// DRIVE / MOTORS
// -------------------------------------------------


void motors_off() 
{
	motor[rightDrive] = 0;
	motor[leftDrive] = 0;
}

void move_forwards(int ms) 
{
	int speed = motorSpeed;
	
	motor[rightDrive] = motorSpeed; // Motor on port2 is run at half (63) power forward
	motor[leftDrive]  = motorSpeed;	// Motor on port3 is run at half (63) power forward
	wait1Msec(ms);
}

void move_forwards_dist(int amount) 
{
	int speed = 50;
        
	nMotorEncoder[leftDrive] = 0;
  	nMotorEncoder[rightDrive] = 0;
  
  	while (nMotorEncoder[leftDrive] > -amount && nMotorEncoder[rightDrive] > -amount && nMotorEncoder[leftDrive] < amount && nMotorEncoder[rightDrive] < amount) 
  	{
		motor[leftDrive] = -speed; 	// Motor on port2 is run at half (63) power forward
	  	motor[rightDrive]  = -speed;    // Motor on port3 is run at half (63) power forward
	  	wait1Msec(1);
	  
		checkArm();
  	}
  
  	motors_off();
}

void move_backwards(int ms)
{
	motor[rightDrive] = -motorSpeed; 	// Motor on port2 is run at half (63) power forward
	motor[leftDrive]  = -motorSpeed;	// Motor on port3 is run at half (63) power forward
	wait1Msec(ms);
}

void turn_left(int ms)
{
	motor[rightDrive] = -motorSpeed;	// Motor on port2 is run at half (63) power forward
	motor[leftDrive]  = motorSpeed;		// Motor on port3 is run at half (63) power forward
	wait1Msec(ms);
}

void turn_left(int ms, int power) 
{
	motor[rightDrive] = -power; 	// Motor on port2 is run at half (63) power forward
	motor[leftDrive]  = power;	// Motor on port3 is run at half (63) power forward
	wait1Msec(ms);
}

void turn_right(int ms, int power) 
{
	motor[rightDrive] = power; // Motor on port2 is run at half (63) power forward
	motor[leftDrive]  = -power;	// Motor on port3 is run at half (63) power forward
	wait1Msec(ms);
}

void turn_left_angle(int angle) 
{
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	//int amount = angle * angleConversion;
	int amount = angle;
	amount += leftConversion;
	
	while (nMotorEncoder[leftDrive] > -amount && nMotorEncoder[rightDrive] < amount) 
	{
		turn_left(1, motorSpeed / 2);
		checkArm();
	}
	
	// Reverse power shortly.
	turn_right(15, motorSpeed);
	
	motors_off();
	
}

void turn_right_angle(int angle) 
{
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	//int amount = angle * angleConversion;
	int amount = angle;
	
	while (nMotorEncoder[leftDrive] < amount && nMotorEncoder[rightDrive] > -amount) 
	{
		turn_right(1, motorSpeed / 2);
		checkArm();
	}
	
	// Reverse power shortly.
	turn_left(15, motorSpeed);
	
	motors_off();
}

void turn_right(int ms)
{
	motor[rightDrive] = motorSpeed; 	// Motor on port2 is run at half (63) power forward
	motor[leftDrive]  = -motorSpeed;	// Motor on port3 is run at half (63) power forward
	wait1Msec(ms);
}

// -------------------------------------------------
// DRIVE / MOTORS
// =================================================

// =================================================
// SONAR
// -------------------------------------------------

void lookAtAngle(int angle)
{
	motor[sonarLook] = angle + sonarOffset;
	wait1Msec(1);
}

void lookForward()
{
	lookAtAngle((int)0);
}

int checkFrontDistance() 
{
	
}

// -------------------------------------------------
// END SONAR
// =================================================

// =================================================
// Control Arm
// -------------------------------------------------

void armOff() {
	motor[armDrive] = 0;
}

void checkArm() 
{
	return;
	
	if (SensorValue(armLimit)) 
	{
		// Force motor up.
		motor[armDrive] = maxPower;
		wait10Msec(5);
		
		// Set armDrive to something higher.
		angle = 1900;
	}
	int degrees = SensorValue(armAngle);
	if (degrees < angle) {
		// Move motor up.
		if (degrees + minPowerThreshold < angle)
			motor[armDrive] = maxPower;
		else motor[armDrive] = minPower;
	}
	else if (degrees > angle) {
		// Move motor down.
		motor[armDrive] = -minPower;
	}
	else {
		// Turn motor off
		motor[armDrive] = 0;
	}
}

void setArm(int degrees) {
	angle = degrees; //(degrees * conversion)(degrees - min) / conversion;
	checkArm();
}

void setArmLiteral(int degrees) {
	angle = degrees;
	checkArm();
}

// -------------------------------------------------
// END CONTROL ARM
// =================================================

// =================================================
// STATE MANAGER
// -------------------------------------------------

void checkState() {
	// Check arm state.
	checkArm();
}

// -------------------------------------------------
// END STATE MANAGER
// =================================================

// =================================================
// GRID
// -------------------------------------------------

void setBlockState(int x, int y, bool state) {
	if (x < gridWidth && y < gridHeight && x >= 0 && y >= 0) {
		grid[y][x] = state;
	}
}

void setBlockState_range(int xIncrement, int yIncrement, int startX, int startY, int distanceClear) {
	distanceClear = distanceClear / 20;
	for (int x = 0; x < 10; x++) {
		startX += xIncrement;
		startY += yIncrement;
		
		if (x < distanceClear) {
			setBlockState(startX, startY, true);
		}
		else if (x == distanceClear) {
			setBlockState(startX, startY, false);
			break;
		}
	}
}

void sensorMapCheck(int sensorVal, int cangle) {
	// Update 10 blocks in front.
	// If 0, modify all x values to the right.
	if (cangle == 0) {
		setBlockState_range(1, 0, Me.position.x, Me.position.y, sensorVal);
	}
	else if (cangle == 90) {
		setBlockState_range(0, 1, Me.position.x, Me.position.y, sensorVal);
	}
	else if (cangle == 180) {
		setBlockState_range(-1, 0, Me.position.x, Me.position.y, sensorVal);
	}
	else if (cangle == 270) {
		setBlockState_range(0, -1, Me.position.x, Me.position.y, sensorVal);
	}
}

void checkMap() {
	sensorMapCheck(SensorValue(sonarFront), Me.direction * 90);
	sensorMapCheck(SensorValue(sonarLeft), Me.direction * 90 + 90 % 360);
	int minusAngle = Me.direction * 90 - 90;
	if (minusAngle < 0) minusAngle = 270;
	sensorMapCheck(SensorValue(sonarRight), minusAngle);
}

int blockClearance(int distance) {
	if (distance <= 0) return 10;
	int result = distance / 12;
	if (distance > 10) return 10;
	return result;
}

// -------------------------------------------------
// END GRID
// =================================================

// =================================================
// PATH PLANNING
// -------------------------------------------------

int genericDistance(int x1, int y1, int x2, int y2) {
	return abs(x2 - x1) + abs(y2 - y1);
}

bool bestFirst_route() {
	initOpen();
	pathIndex = 0;
	int distance = 1000;
	int nodeX = -1;
	int nodeY = -1;
	while (openCells > 0) {
		checkArm();
		open[currentY][currentX] = false;
		
		if (currentX == goalX && currentY == goalY) {
			return true;
		}
		
	  distance = 1000;
	  if (currentX - 1 >= 0 && open[currentY][currentX - 1]) {
	  	nodeX = currentX - 1;
	  	nodeY = currentY;
	  	distance = genericDistance(currentX - 1, currentY, goalX, goalY);
	  }
	  
	  if (currentY - 1 >= 0 && open[currentY - 1][currentX] && genericDistance(currentX, currentY - 1, goalX, goalY) < distance) {
	  	nodeX = currentX;
	  	nodeY = currentY - 1;
	  	distance = genericDistance(currentX, currentY - 1, goalX, goalY);
	  }
	  
	  if (currentX + 1 < gridWidth && open[currentY][currentX + 1] && genericDistance(currentX + 1, currentY, goalX, goalY) < distance) {
	  	nodeX = currentX + 1;
	  	nodeY = currentY;
	  	distance = genericDistance(currentX + 1, currentY, goalX, goalY);
	  }
	  
	  if (currentY + 1 < gridHeight && open[currentY + 1][currentX] && genericDistance(currentX, currentY + 1, goalX, goalY) < distance) {
	  	nodeX = currentX;
	  	nodeY = currentY + 1;
	  	distance = genericDistance(currentX, currentY + 1, goalX, goalY);
	  }
	  
	  if (nodeX == -1 || nodeY == -1) {
	  	if (pathIndex == 0) return false;
	  	// Step backwards.
	  	pathIndex = pathIndex - 1;
	  	currentX = path[pathIndex - 1].x;
	  	currentY = path[pathIndex - 1].y;
	  	continue;
	  }
	  if (pathIndex >= gridWidth * gridHeight) return false;
	  currentX = nodeX;
	  currentY = nodeY;
	  path[pathIndex].x = currentX;
	  path[pathIndex].y = currentY;
	  pathIndex = pathIndex + 1;
	}
	return false;
}

// Call this function to have the robot travel down the hallway.
void travelHallway()
{
	// We need to keep the robot in the middle of the hallway. To do that, we will use the three sonars on our robot.
	// The front, left, and right sonars will be used.
	// Front: To determine if we have reached the end of the hall or not.
	// Left: To ensure we are the same distance away from the left wall as the right wall.
	// Right: To ensure we are the same distance away from the right wall as the left wall.
	// We will 60 for the normal speed.
	// We will use 70 for the slightly higher speed.

	int leftMotorSpeed;
	int rightMotorSpeed;

	// Set arm to be parallel with the ground.
	setArmLiteral(1800);

	// Set the initial motor speeds;
	leftMotorSpeed = -25;
	rightMotorSpeed = -25;

	// While the robot isn't to close to something in front of it.
	while(SensorValue[sonarFront] > 10 || SensorValue[sonarFront] == -1)
	{
		checkArm();
		// If the sonar values are the same.
		if(SensorValue[sonarLeft] == SensorValue[sonarRight])
		{
			// Set the motor speeds to the same value
			leftMotorSpeed = -70;
			rightMotorSpeed = -70;
		}
		// If the left sonar value is greater than the right sonar value, we are closer to the right wall.
		else if(SensorValue[sonarLeft] > SensorValue[sonarRight])
		{
			// Set the left motor speed slightly higher. This should let the robot drift to the left.
			leftMotorSpeed = -30;
			rightMotorSpeed = -80;
		}
		// If the right sonar value is greater than the left sonar value, we are closer to the left wall.
		else if(SensorValue[sonarRight] > SensorValue[sonarLeft])
		{
			// Set the right motor speed slightly higher. This should let the robot drift to the right.
			leftMotorSpeed = -80;
			rightMotorSpeed = -30;
		}

		// Move forward using the speed variables for each motor.
		motor[leftDrive] = leftMotorSpeed;
		motor[rightDrive] = rightMotorSpeed;
	}

	// Stop moving the robot
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}


// -------------------------------------------------
// END PATH PLANNING
// =================================================


void initGrid() {
	// Initialize
	for (int y = 0; y < gridHeight; y++) {
		for (int x = 0; x < gridWidth; x++) {
			grid[y][x] = true;
		}
	}
	
	grid[Me.position.y][Me.position.x] = false;
}

void initOpen() {
	// Initialize
	for (int y = 0; y < gridHeight; y++) {
		for (int x = 0; x < gridWidth; x++) {
			open[y][x] = grid[y][x];
		}
	}
	
	currentX = Me.position.x;
	currentY = Me.position.y;
}
// The motor and wait values may need adjusted so we don't burn up the motor.
void openClaw()
{
	motor[clawDrive] = 100;	// Open the claw.
	wait1Msec(450);			      // Let the claw continue opening.
	motor[clawDrive] = 0;	  // Stop the claw from opening any more. 
}

// The motor and wait values may need adjusted so we don't burn up the motor.
void closeClaw()
{
	motor[clawDrive] = -80;  // Close the claw.
	wait1Msec(500);			      // Let the claw continue closing.
  motor[clawDrive] = -20;  // Close the claw.
}
void pickUpCan()
{
	openClaw();
	while(SensorValue[armLimit]<1)
	{
		motor[armDrive]=-10;
	}
	motor[armDrive]=0;
	
	closeClaw();

	motor[armDrive]=20;
	wait10Msec(10);
	
	//setArmLiteral(1800);
	
	checkArm();	

}

void findCan()
{
	int t=0;
	
	//turn left 5 increments trying to find can (might need to be higher than 5)
	while(t < 5)
	{
		if(SensorValue[sonarFront] <= 10)
		{
			//found the edge of the can, continue moving slightly
			wait10Msec(20);
			motors_off();
			pickUpCan();
			t=5;
			break;
		}
		else
		{
			//continue rotating right
			motor[leftDrive]=40;
			motor[rightDrive]=-40;
			wait10Msec(40);
			t+=1;
		}
		
	}
	motors_off();
	t=0;
	
	//turn right 10 increments trying to find can	
	while(t < 10)
	{	
		if(SensorValue[sonarFront] <= 10)
		{
			//found the edge of the can, continue moving slightly
			wait10Msec(20);
			motors_off();
			
			pickUpCan();
			t=10;
			break;
		}
		else
		{
			//continue rotating left
			motor[leftDrive]=-40;
			motor[rightDrive]=40;
			wait10Msec(40);			
			t+=1;
		}
		
	}		
	motors_off();
	
}

task main()
{

	findCan();
	
	motor[clawDrive]=0;
}
