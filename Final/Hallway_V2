#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, dgtl3,  armLimit,       sensorTouch)
#pragma config(Sensor, dgtl7,  sonarRight,     sensorSONAR_inch)
#pragma config(Sensor, dgtl9,  sonarLeft,      sensorSONAR_inch)
#pragma config(Sensor, dgtl11, sonarFront,     sensorSONAR_inch)
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port7,           armDrive,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightDrive,    tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int distanceToLeftWall, distanceToRightWall;

// Call this function first to set up the sonar.
void setupSonar()
{
	// We need to get the initial position of the robot. This mean that THE ROBOT MUST BE STARTED FACING FOWARDS
	// Otherwise, the robot will go in a diagonal line. The robot should not be touched after the program is set to run.
	// Otherwise, the sonar could have a large flucuation and mess the distances up.
	
	// Let the robot settle down and not move for four seconds. There is no particular reason for four seconds.
	wait1MSec(4000);

	// Now the robot hasn't moved for four seconds, get the distance to the wall.
	distanceToLeftWall = SensorValue[sonarLeft];
	distanceToRightWall = SensorValue[sonarRight];
}

void driftLeft(int leftMotorSpeed, int rightMotorSpeed)
{
	// Drift while the robot is moving back to the center of the hallway, and moving left.
	while(SensorValue[sonarLeft] > distanceToLeftWall)
	{
		motor[leftDrive] = leftMotorSpeed;
		motor[rightDrive] = rightMotorSpeed;
	}
}

void driftRight(int leftMotorSpeed, intRightMotorSpeed)
{
	// Drift while the robot is moving back to the center of the hallway, and moving right.
	while(SensorValue[sonarRight] > distanceToRightWall)
	{
		motor[leftDrive] = leftMotorSpeed;
		motor[rightDrive] = rightMotorSpeed;
	}
}

// Call this function to have the robot travel down the hallway.
void travelHallway()
{
	// We need to keep the robot in the middle of the hallway. To do that, we will use the three sonars on our robot.
	// The front, left, and right sonars will be used.
	// Front: To determine if we have reached the end of the hall or not.
	// Left: To ensure we are the same distance away from the left wall as the right wall.
	// Right: To ensure we are the same distance away from the right wall as the left wall.
	// We will 60 for the normal speed.
	// We will use 70 for the slightly higher speed.

	// Holds the current speed of each motor.
	int leftMotorSpeed, rightMotorSpeed;

	// Set arm to be parallel with the ground.
	setArm(25);

	// Set the initial motor speeds;
	leftMotorSpeed = -80;
	rightMotorSpeed = -80;

	// Travel down the hallway forever.
	while(true)
	{
		// If we are about to hit something, back up so we can continue to move.
		// THIS MAY NEED CHANGED TO AN && INSTEAD OF A ||. V LINE BELOW V
		if(SensorValue[sonarFront] < 10 || SensorValue[sonarFront] == -1)
		{
				// Stop so we don't do a wheelie.
				motor[leftDrive] = 0;
				motor[rightDrive] = 0;
                
				// Move the robot backwards.
				motor[leftDrive] = 30;
				motor[rightDrive] = 30;
                        
				// Back up for 2.5 seconds.
				wait1Msec(2500);
                        
				// Stop moving the robot.
				motor[leftDrive] = 0;
				motor[rightDrive] = 0;
		}
        
		// If the sonar values are the same, go straight.
		else if((SensorValue[sonarLeft] == distanceToLeftWall) && (SensorValue[sonarRight]) == distanceToRightWall))
		{
				// Set the motor speeds to the same value.
				leftMotorSpeed = -30;
				rightMotorSpeed = -30;

				// Move straight.
				motor[leftDrive] = leftMotorSpeed;
				motor[rightDrive] = rightMotorSpeed;
		}
		// If the left sonar value is greater than the right sonar value, we are closer to the right wall.
		else if((SensorValue[sonarLeft] > SensorValue[sonarRight]))
		{
				// Set the left motor speed slightly higher. This should let the robot drift to the left.
				leftMotorSpeed = -80;
				rightMotorSpeed = -30;

				// Drift left, back to the center of the hallway.
				driftLeft(leftMotorSpeed, rightMotorSpeed);
		}
		// If the right sonar value is greater than the left sonar value, we are closer to the left wall.
		else if(SensorValue[sonarRight] > SensorValue[sonarLeft])
		{
				// Set the right motor speed slightly higher. This should let the robot drift to the right.
				leftMotorSpeed = -30;
				rightMotorSpeed = -80;

				// Drift right, back to the center of the hallway.
				driftRight(leftMotorSpeed, rightMotorSpeed);
		}
	}

	// Stop moving the robot
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}

task main()
{
	// Set up sonar.
	setupSonar();

    // Travel down the hallway.
    travelHallway();
}
