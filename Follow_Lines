#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, in6,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in7,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in8,    leftLine,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  rearRightBumper, sensorTouch)
#pragma config(Sensor, dgtl2,  rearLeftBumper, sensorTouch)
#pragma config(Sensor, dgtl3,  armLimit,       sensorTouch)
#pragma config(Sensor, dgtl11, sonar,          sensorSONAR_cm)
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           sonarLook,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           clawDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armDrive,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightDrive,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ===============================================
// TYPEDEF
// -----------------------------------------------

typedef enum {
	none,
	left,
	middle,
	right
} lineMarker;

typedef struct {
	bool leftLineDark;
	bool middleLineDark;
	bool rightLineDark;
	int leftLineVal;
	int middleLineVal;
	int rightLineVal;
	lineMarker lastMarker;
} lineState;

typedef struct {
	int limit;
	int speed;
} speedThreshold;

// ------------------------------------------------
// END TYPEDEF
// ================================================


// ================================================
// GLOBALS
// ------------------------------------------------
const int sonarRangeOfMotion = 100;
int degreesPerSecond = 0;
int currentAngle = 0;

// Drive Speeds
int motorSpeed = 100;
int minMotorSpeed = 40;

speedThreshold thresholdLimits[10];
thresholdLimits[0].limit = 300;
thresholdLimits[0].speed = motorSpeed;
thresholdLimits[1].limit = 200;
thresholdLimits[1].speed = motorSpeed / 2;
thresholdLimits[2].limit = 100;
thresholdLimits[2].speed = minMotorSpeed;

const int lightThreshold = 40;

int angle = 0;
int angleROM = 90;
int min = 1300;
int max = 3400;
int conversion = (max - min) / angleROM;
int maxPower = 40;
int minPower = 25;
int minPowerThreshold = 2;
int sonarOffset = -10;
int frontDistance = 0;

// Prototype function so it can be called from other methods defined before this one is defined.
void checkArm();
void checkState();
void lookAtAngle(int angle);

lineState lState;
// ------------------------------------------------
// END GLOBALS
// ================================================

// =================================================
// DRIVE / MOTORS
// -------------------------------------------------

void move_forwards(int ms){
	int speed = motorSpeed;
	
		motor[rightDrive] = motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void move_backwards(int ms){
		motor[rightDrive] = -motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = -motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_left(int ms){
		motor[rightDrive] = -motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_left(int ms, int power) {
		motor[rightDrive] = power; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_right(int ms){
		motor[rightDrive] = motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = -motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_right(int ms, int power) {
		motor[rightDrive] = motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = power;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

// -------------------------------------------------
// DRIVE / MOTORS
// =================================================

// =================================================
// SONAR
// -------------------------------------------------

void lookAtAngle(int angle)
{
	motor[sonarLook] = angle + sonarOffset;
	wait1Msec(1);
}

void lookForward()
{
	lookAtAngle((int)0);
}

int checkFrontDistance() {
	
}

// -------------------------------------------------
// END SONAR
// =================================================

// =================================================
// LINE TRACKING
// -------------------------------------------------

void checkLines() {
	checkState();

	int lowest, highest;

	// May have to update to allow multiple markers to be dark previously.
	if (lState.leftLineDark) lState.lastMarker = left;
	else if (lState.middleLineDark) lState.lastMarker = middle;
	else if (lState.rightLineDark) lState.lastMarker = right;

	lState.leftLineVal = 0;
	lState.middleLineVal = 0;
	lState.rightLineVal = 0;
	lState.leftLineDark = false;
	lState.middleLineDark = false;
	lState.rightLineDark = false;

	lState.leftLineVal = SensorValue(leftLine);
	lState.middleLineVal = SensorValue(middleLine);
	lState.rightLineVal = SensorValue(rightLine);

	lowest = lState.leftLineVal;
	highest = lState.leftLineVal;
	if (lState.middleLineVal < lowest) lowest = lState.middleLineVal;
	else highest = lState.middleLineVal;

	if (lState.rightLineVal < lowest) lowest = lState.rightLineVal;
	if (lState.rightLineVal > highest) highest = lState.rightLineVal;

	if (highest - lowest > lightThreshold) {
		// Determine which ones are dark.
		lState.leftLineDark = false;
		lState.middleLineDark = false;
		lState.rightLineDark = false;

		if (lState.leftLineVal < highest - lightThreshold) {
			lState.leftLineDark = true;
		}

		if (lState.middleLineVal < highest - lightThreshold) {
			lState.middleLineDark = true;
		}

		if (lState.rightLineVal < highest - lightThreshold) {
			lState.rightLineDark = true;
		}
	}
}

void lineTracker() {
	while (SensorValue(rearRightBumper) == 0 && SensorValue(rearLeftBumper) == 0) {
		checkLines();

		// Is a line dark?
		if (lState.leftLineDark || lState.rightLineDark || lState.middleLineDark) {
			// Left line is dark by itself.
			if (lState.leftLineDark && !lState.rightLineDark && !lState.middleLineDark) {
				while (lState.leftLineDark) {
					turn_right(10);
					checkLines();
				}
			}

			// Right line is dark by itself.
			if (!lState.leftLineDark && lState.rightLineDark && !lState.middleLineDark) {
				while (lState.rightLineDark) {
					turn_left(10);
					checkLines();
				}
			}

			// Middle line is dark by itself.
			if (!lState.leftLineDark && !lState.rightLineDark && lState.middleLineDark) {
				if (lState.lastMarker == left) {
					// Turn right until left goes off again. Then, go forward and left slightly.
					while (!lState.leftLineDark) {
						turn_right(10);
						checkLines();
					}
					move_forwards(20);
					turn_left(20);
				}
				else {
					// Turn left until right goes off again. Then, go forward and right slightly.
					while (!lState.rightLineDark) {
						turn_left(10);
						checkLines();
					}
					move_forwards(20);
					turn_right(20);
				}
			}

			// If any two or all three are dark
			if ((lState.leftLineDark && lState.rightLineDark) || (lState.leftLineDark && lState.middleLineDark) || (lState.middleLineDark && lState.rightLineDark)) {
				// Back up and turn away from the last marker.
			  move_backwards(40);
			  if (lState.lastMarker == left) {
			  	// Turn right a bit.
			    turn_right(40);
			  }
			  else {
			  	turn_left(40);
			  }
			}
		}

		move_forwards(10);
	}
}

// -------------------------------------------------
// END LINE TRACKING
// =================================================

// =================================================
// Control Arm
// -------------------------------------------------

void checkArm() {
	if (SensorValue(armLimit)) {
		// Force motor up.
		motor[armDrive] = maxPower;
		wait10MSec(5);
		
		// Set armDrive to something higher.
		armAngle = 10;
	}
	int degrees = SensorValue(armAngle);
	degrees = (degrees - min) / conversion;
	if (degrees < angle) {
		// Move motor up.
		if (degrees + minPowerThreshold < angle)
			motor[armDrive] = maxPower;
		else motor[armDrive] = minPower;
	}
	else if (degrees > angle) {
		// Move motor down.
		motor[armDrive] = -minPower;
	}
	else {
		// Turn motor off
		motor[armDrive] = 0;
	}
}

void setArm(int degrees) {
	angle = degrees;
	checkArm();
}

// -------------------------------------------------
// END CONTROL ARM
// =================================================



// =================================================
// STATE MANAGER
// -------------------------------------------------

void checkState() {
	// Check arm state.
	checkArm();
}

// -------------------------------------------------
// END STATE MANAGER
// =================================================

task main()
{
	setArm(25);
	wait10Msec(5);
	lookForward();

	while (true) {
		lineTracker();

		// Check ultrasonic distance.

	}

}
