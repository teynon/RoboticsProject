#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, in6,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in7,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in8,    rightLine,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  rearRightBumper, sensorTouch)
#pragma config(Sensor, dgtl2,  rearLeftBumper, sensorTouch)
#pragma config(Sensor, dgtl3,  sonarLimits,    sensorTouch)
#pragma config(Sensor, dgtl4,  light,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, sonar,          sensorSONAR_cm)
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           sonarDrive,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           clawDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armDrive,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightDrive,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int const sonarRangeOfMotion = 100;
int degreesPerSecond = 0;
int currentAngle = 0;

int lightThreshold = 40;
bool leftLineDark = false;
bool middleLineDark = false;
bool rightLineDark = false;
bool go_forward = false;

typedef enum {
	none,
	left,
	middle,
	right
} lineMarker;

lineMarker lastDark = none;

void move_forwards(int ms){
		motor[rightDrive] = 63; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = 63;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void move_backwards(int ms){
		motor[rightDrive] = -63; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = -63;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_left(int ms){
		motor[rightDrive] = 63; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = -63;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_left(int ms, int power) {
		motor[rightDrive] = 63; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = power;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_right(int ms){
		motor[rightDrive] = -63; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = 63;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_right(int ms, int power) {
		motor[rightDrive] = power; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = 63;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void calibrateSonar()
{
	int counter = 0;
	
	SensorValue[4] = true;

	// Move the sonar until it hits one of the limit switches.
	while(SensorValue(sonarLimits) == 0)
	{
		motor[sonarDrive] = 30;
		wait1Msec(5);
	}

	motor[sonarDrive] = -30;	// Move in the other direction.
	wait10Msec(15);						// Let it get off the sensor.
	motor[sonarDrive] = 0;		// Stop the motor.

	// Now we are at the starting position. We need to move to the other side
	//  and record a time.
	while(SensorValue(sonarLimits))
	{
		motor[sonarDrive] = -30;		// Move the motor until it hits the opposite limit switch.
		wait1Msec(5);
		counter = counter + 5;		// Increment the counter.
	}

	motor[sonarDrive] = 0;

	degreesPerSecond = sonarRangeOfMotion / counter;
	currentAngle = 0;
}


void lookAtAngle(int angle)
{
	int direction = 30;
	int timeToMove = 0;
	
	// Get direction to move
	if (angle > currentAngle) direction *= -1;
	timeToMove = abs(angle - currentAngle) / degreesPerSecond;
	
	// Turn for X Seconds
	while (SensorValue(sonarLimits) == 0 && timeToMove > 0) {
		motor[sonarDrive] = direction;
		wait1Msec(5);
	}
	
	motor[sonarDrive] = 0;
}

void lookForward()
{
	lookAtAngle((int)(sonarRangeOfMotion / 2));
}


task main()
{
	int leftL = 0;
	int middleL = 0;
	int rightL = 0;
	int lowest = 0;
	int highest = 0;

	while (SensorValue(rearRightBumper) == 0 && SensorValue(rearLeftBumper) == 0) {
		leftL = SensorValue(leftLine);
		middleL = SensorValue(middleLine);
		rightL = SensorValue(rightLine);
		go_forward = true;
		
		lowest = leftL;
		highest = leftL;
		if (middleL < lowest) lowest = middleL;
		else highest = middleL;
		
		if (rightL < lowest) lowest = rightL;
		if (rightL > highest) highest = rightL;
		
		// Is there a notable difference?
		if (highest - lowest > lightThreshold) {
			// Determine which ones are dark.
			leftLineDark = false;
			middleLineDark = false;
			rightLineDark = false;
			
			if (leftL < highest - lightThreshold) {
				if (lastDark == middle) {
					// Turn right!
					while (
					turn_right(50);
				}
				leftLineDark = true;
				lastDark = left;
			}
			
			if (middleL < highest - lightThreshold) {
				if (lastDark == left) {
					// Turn left!
					turn_left(50);
				}
				else if (lastDark == right) {
					// Turn left!
					turn_right(50);
				}
				
				middleLineDark = true;
				lastDark = middle;
			}
			
			if (rightL < highest - lightThreshold) {
				if (lastDark == middle) {
					// Turn left!
					turn_left(50);
				}
				rightLineDark = true;
				lastDark = right;
			}
			
			// If left is dark and middle and right are not, turn right.
			if (leftLineDark && !middleLineDark && !rightLineDark) {
				turn_left(80, 10);
				go_forward = false;
			}
			
			// If middle right is dark and left and middle are not, turn left.
			if (!leftLineDark && !middleLineDark && rightLineDark) {
				turn_right(80, 10);
				go_forward = false;
			}
		}
		
		if (go_forward)
			move_forwards(10);
	}

	calibrateSonar();
	lookForward();

	/*while(true)
	{
		while(SensorValue(sonarLimits) == 0)
		{
			motor[sonarDrive] = 30;
			wait1Msec(5);
		}

		while(SensorValue(sonarLimits) == 1)
		{
			motor[sonarDrive] = -30;
			wait1Msec(1);
		}

		//

		while(SensorValue(sonarLimits) == 0)
		{
			motor[sonarDrive] = -30;
			wait1Msec(1);
		}

		while(SensorValue(sonarLimits) == 1)
		{
			motor[sonarDrive] = 30;
			wait1Msec(1);
		}
	}*/

}
