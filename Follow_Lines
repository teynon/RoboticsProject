#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, in6,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in7,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in8,    leftLine,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  rearRightBumper, sensorTouch)
#pragma config(Sensor, dgtl2,  rearLeftBumper, sensorTouch)
#pragma config(Sensor, dgtl3,  sonarLimits,    sensorTouch)
#pragma config(Sensor, dgtl4,  light,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, sonar,          sensorSONAR_cm)
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port2,           sonarDrive,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           clawDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armDrive,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightDrive,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ===============================================
// TYPEDEF
// -----------------------------------------------

typedef enum {
	none,
	left,
	middle,
	right
} lineMarker;

typedef struct {
	bool leftLineDark;
	bool middleLineDark;
	bool rightLineDark;
	int leftLineVal;
	int middleLineVal;
	int rightLineVal;
	lineMarker lastMarker;
} lineState;

// ------------------------------------------------
// END TYPEDEF
// ================================================


// ================================================
// GLOBALS
// ------------------------------------------------
const int sonarRangeOfMotion = 100;
int degreesPerSecond = 0;
int currentAngle = 0;
int motorSpeed = 45;

const int lightThreshold = 40;

int angle = 0;
int angleROM = 90;
int min = 1300;
int max = 3400;
int conversion = (max - min) / angleROM;
int maxPower = 40;
int minPower = 25;
int minPowerThreshold = 2;

// Prototype function so it can be called from other methods defined before this one is defined.
void checkArm();
void checkState();
void lookAtAngle(int angle);

lineState lState;
// ------------------------------------------------
// END GLOBALS
// ================================================

// =================================================
// DRIVE / MOTORS
// -------------------------------------------------

void move_forwards(int ms){
		motor[rightDrive] = motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void move_backwards(int ms){
		motor[rightDrive] = -motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = -motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_left(int ms){
		motor[rightDrive] = -motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_left(int ms, int power) {
		motor[rightDrive] = power; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_right(int ms){
		motor[rightDrive] = motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = -motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_right(int ms, int power) {
		motor[rightDrive] = motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = power;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

// -------------------------------------------------
// DRIVE / MOTORS
// =================================================

// =================================================
// SONAR
// -------------------------------------------------
void calibrateSonar()
{
	int counter = 0;

	SensorValue[4] = true;

	// Move the sonar until it hits one of the limit switches.
	while(SensorValue(sonarLimits) == 0)
	{
		checkArm();
		motor[sonarDrive] = 30;
		wait1Msec(5);
	}

	motor[sonarDrive] = -30;	// Move in the other direction.
	wait10Msec(30);						// Let it get off the sensor.
	motor[sonarDrive] = 0;		// Stop the motor.

	// Now we are at the starting position. We need to move to the other side
	//  and record a time.
	while(SensorValue(sonarLimits) == 0)
	{
		checkArm();
		motor[sonarDrive] = -30;		// Move the motor until it hits the opposite limit switch.
		wait1Msec(5);
		counter = counter + 5;		// Increment the counter.
	}

	while (SensorValue(sonarLimits)) {
		checkArm();
		motor[sonarDrive] = 20;	// Move in the other direction.
		wait1Msec(5);						// Let it get off the sensor.
	}
	
	motor[sonarDrive] = 0;

	degreesPerSecond = (sonarRangeOfMotion * 100);
	degreesPerSecond = degreesPerSecond / counter;
	currentAngle = 0;
	lookAtAngle(45);
}


void lookAtAngle(int angle)
{
	int direction = 30;
	int timeToMove = 0;

	// Get direction to move
	if (angle < currentAngle) direction *= -1;
	timeToMove = abs(angle - currentAngle) / degreesPerSecond;

	// Turn for X Seconds
	while (SensorValue(sonarLimits) == 0 && timeToMove > 0) {
		checkArm();
		motor[sonarDrive] = direction;
		wait1Msec(5);
	}

	motor[sonarDrive] = 0;
}

void lookForward()
{
	lookAtAngle((int)(sonarRangeOfMotion / 2));
}
// -------------------------------------------------
// END SONAR
// =================================================

// =================================================
// LINE TRACKING
// -------------------------------------------------

void checkLines() {
	checkState();

	int lowest, highest;

	// May have to update to allow multiple markers to be dark previously.
	if (lState.leftLineDark) lState.lastMarker = left;
	else if (lState.middleLineDark) lState.lastMarker = middle;
	else if (lState.rightLineDark) lState.lastMarker = right;

	lState.leftLineVal = 0;
	lState.middleLineVal = 0;
	lState.rightLineVal = 0;
	lState.leftLineDark = false;
	lState.middleLineDark = false;
	lState.rightLineDark = false;

	lState.leftLineVal = SensorValue(leftLine);
	lState.middleLineVal = SensorValue(middleLine);
	lState.rightLineVal = SensorValue(rightLine);

	lowest = lState.leftLineVal;
	highest = lState.leftLineVal;
	if (lState.middleLineVal < lowest) lowest = lState.middleLineVal;
	else highest = lState.middleLineVal;

	if (lState.rightLineVal < lowest) lowest = lState.rightLineVal;
	if (lState.rightLineVal > highest) highest = lState.rightLineVal;

	if (highest - lowest > lightThreshold) {
		// Determine which ones are dark.
		lState.leftLineDark = false;
		lState.middleLineDark = false;
		lState.rightLineDark = false;

		if (lState.leftLineVal < highest - lightThreshold) {
			lState.leftLineDark = true;
		}

		if (lState.middleLineVal < highest - lightThreshold) {
			lState.middleLineDark = true;
		}

		if (lState.rightLineVal < highest - lightThreshold) {
			lState.rightLineDark = true;
		}
	}
}

void lineTracker() {
	while (SensorValue(rearRightBumper) == 0 && SensorValue(rearLeftBumper) == 0) {
		checkLines();

		// Is a line dark?
		if (lState.leftLineDark || lState.rightLineDark || lState.middleLineDark) {
			// Left line is dark by itself.
			if (lState.leftLineDark && !lState.rightLineDark && !lState.middleLineDark) {
				while (lState.leftLineDark) {
					turn_right(10);
					checkLines();
				}
			}

			// Right line is dark by itself.
			if (!lState.leftLineDark && lState.rightLineDark && !lState.middleLineDark) {
				while (lState.rightLineDark) {
					turn_left(10);
					checkLines();
				}
			}

			// Middle line is dark by itself.
			if (!lState.leftLineDark && !lState.rightLineDark && lState.middleLineDark) {
				if (lState.lastMarker == left) {
					// Turn right until left goes off again. Then, go forward and left slightly.
					while (!lState.leftLineDark) {
						turn_right(10);
						checkLines();
					}
					move_forwards(20);
					turn_left(20);
				}
				else {
					// Turn left until right goes off again. Then, go forward and right slightly.
					while (!lState.rightLineDark) {
						turn_left(10);
						checkLines();
					}
					move_forwards(20);
					turn_right(20);
				}
			}

			// If any two or all three are dark
			if ((lState.leftLineDark && lState.rightLineDark) || (lState.leftLineDark && lState.middleLineDark) || (lState.middleLineDark && lState.rightLineDark)) {
				// Back up and turn away from the last marker.
			  move_backwards(40);
			  if (lState.lastMarker == left) {
			  	// Turn right a bit.
			    turn_right(40);
			  }
			  else {
			  	turn_left(40);
			  }
			}
		}

		move_forwards(10);
	}
}

// -------------------------------------------------
// END LINE TRACKING
// =================================================

// =================================================
// Control Arm
// -------------------------------------------------

void checkArm() {
	int degrees = SensorValue(armAngle);
	degrees = (degrees - min) / conversion;
	if (degrees < angle) {
		// Move motor up.
		if (degrees + minPowerThreshold < angle)
			motor[armDrive] = maxPower;
		else motor[armDrive] = minPower;
	}
	else if (degrees > angle) {
		// Move motor down.
		motor[armDrive] = -minPower;
	}
	else {
		// Turn motor off
		motor[armDrive] = 0;
	}
}

void setArm(int degrees) {
	angle = degrees;
	checkArm();
}

// -------------------------------------------------
// END CONTROL ARM
// =================================================



// =================================================
// STATE MANAGER
// -------------------------------------------------

void checkState() {
	// Check arm state.
	checkArm();
}

// -------------------------------------------------
// END STATE MANAGER
// =================================================

task main()
{
	setArm(25);
	wait10Msec(5);
	//calibrateSonar();
	//lookAtAngle(45);

	while (true) {
		lineTracker();

		// Check ultrasonic distance.

	}

}
