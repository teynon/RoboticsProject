#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, in6,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in7,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in8,    leftLine,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  rearRightBumper, sensorTouch)
#pragma config(Sensor, dgtl2,  rearLeftBumper, sensorTouch)
#pragma config(Sensor, dgtl3,  armLimit,       sensorTouch)
#pragma config(Sensor, dgtl7,  sonarRight,     sensorSONAR_inch)
#pragma config(Sensor, dgtl9,  sonarLeft,      sensorSONAR_inch)
#pragma config(Sensor, dgtl11, sonarFront,     sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  debugleftI2C,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  debugRightI2C,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           sonarLook,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           clawDrive,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armDrive,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightDrive,    tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ===============================================
// TYPEDEF
// -----------------------------------------------

typedef enum {
	none,
	left,
	middle,
	right
} lineMarker;

typedef enum {
	unknown,
	clear,
	blocked
} blockState;

typedef struct {
	bool leftLineDark;
	bool middleLineDark;
	bool rightLineDark;
	int leftLineVal;
	int middleLineVal;
	int rightLineVal;
	lineMarker lastMarker;
} lineState;

typedef struct {
	int limit;
	int speed;
} speedThreshold;

typedef struct {
	int x;
	int y;
	blockState state;
} cell;

typedef struct {
	cell position;
	int direction;
	cell goal;
} robot;

// ------------------------------------------------
// END TYPEDEF
// ================================================


// ================================================
// GLOBALS
// ------------------------------------------------
const int sonarRangeOfMotion = 100;
int degreesPerSecond = 0;
int currentAngle = 0;
int angleConversion = 5;

robot Me;

// Drive Speeds
int motorSpeed = 100;
int minMotorSpeed = 40;
int angle90 = 510;

speedThreshold thresholdLimits[10];

const int gridWidth = 50;
const int gridHeight = 50;
blockState grid[gridWidth][gridHeight];

//thresholdLimits[0].limit = 300;
//thresholdLimits[0].speed = motorSpeed;
//thresholdLimits[1].limit = 200;
//thresholdLimits[1].speed = motorSpeed / 2;
//thresholdLimits[2].limit = 100;
//thresholdLimits[2].speed = minMotorSpeed;

const int lightThreshold = 40;

int angle = 0;
int angleROM = 90;
int min = 1300;
int max = 3400;
int conversion = (max - min) / angleROM;
int maxPower = 40;
int minPower = 25;
int minPowerThreshold = 2;
int sonarOffset = -10;
int frontDistance = 0;

// Prototype function so it can be called from other methods defined before this one is defined.
void checkArm();
void checkState();
void lookAtAngle(int angle);

lineState lState;
// ------------------------------------------------
// END GLOBALS
// ================================================

// =================================================
// DRIVE / MOTORS
// -------------------------------------------------

void move_forwards(int ms) {
	int speed = motorSpeed;
	
	motor[rightDrive] = motorSpeed; // Motor on port2 is run at half (63) power forward
	motor[leftDrive]  = motorSpeed;	// Motor on port3 is run at half (63) power forward
	wait1Msec(ms);
}
void motors_off() {
	motor[rightDrive] = 0;
	motor[leftDrive] = 0;
}

void move_backwards(int ms){
		motor[rightDrive] = -motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = -motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_left(int ms){
		motor[rightDrive] = -motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_left(int ms, int power) {
		motor[rightDrive] = -power; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = power;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_right(int ms, int power) {
		motor[rightDrive] = power; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = -power;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

void turn_left_angle(int angle) {
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	//int amount = angle * angleConversion;
	int amount = angle;
	
	while (nMotorEncoder[leftDrive] > -amount && nMotorEncoder[rightDrive] < amount) {
		turn_left(1, motorSpeed / 2);
	}
	
	// Reverse power shortly.
	turn_right(15, motorSpeed);
	
	motors_off();
	
}

void turn_right_angle(int angle) {
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	//int amount = angle * angleConversion;
	int amount = angle;
	
	while (nMotorEncoder[leftDrive] < amount && nMotorEncoder[rightDrive] > -amount) {
		turn_right(1, motorSpeed / 2);
	}
	
	// Reverse power shortly.
	turn_left(15, motorSpeed);
	
	motors_off();
}

void turn_right(int ms){
		motor[rightDrive] = motorSpeed; // Motor on port2 is run at half (63) power forward
		motor[leftDrive]  = -motorSpeed;	// Motor on port3 is run at half (63) power forward
		wait1Msec(ms);
}

// -------------------------------------------------
// DRIVE / MOTORS
// =================================================

// =================================================
// SONAR
// -------------------------------------------------

void lookAtAngle(int angle)
{
	motor[sonarLook] = angle + sonarOffset;
	wait1Msec(1);
}

void lookForward()
{
	lookAtAngle((int)0);
}

int checkFrontDistance() {
	
}

// -------------------------------------------------
// END SONAR
// =================================================

// =================================================
// LINE TRACKING
// -------------------------------------------------

void checkLines() {
	checkState();

	int lowest, highest;

	// May have to update to allow multiple markers to be dark previously.
	if (lState.leftLineDark) lState.lastMarker = left;
	else if (lState.middleLineDark) lState.lastMarker = middle;
	else if (lState.rightLineDark) lState.lastMarker = right;

	lState.leftLineVal = 0;
	lState.middleLineVal = 0;
	lState.rightLineVal = 0;
	lState.leftLineDark = false;
	lState.middleLineDark = false;
	lState.rightLineDark = false;

	lState.leftLineVal = SensorValue(leftLine);
	lState.middleLineVal = SensorValue(middleLine);
	lState.rightLineVal = SensorValue(rightLine);

	lowest = lState.leftLineVal;
	highest = lState.leftLineVal;
	if (lState.middleLineVal < lowest) lowest = lState.middleLineVal;
	else highest = lState.middleLineVal;

	if (lState.rightLineVal < lowest) lowest = lState.rightLineVal;
	if (lState.rightLineVal > highest) highest = lState.rightLineVal;

	if (highest - lowest > lightThreshold) {
		// Determine which ones are dark.
		lState.leftLineDark = false;
		lState.middleLineDark = false;
		lState.rightLineDark = false;

		if (lState.leftLineVal < highest - lightThreshold) {
			lState.leftLineDark = true;
		}

		if (lState.middleLineVal < highest - lightThreshold) {
			lState.middleLineDark = true;
		}

		if (lState.rightLineVal < highest - lightThreshold) {
			lState.rightLineDark = true;
		}
	}
}

void lineTracker() {
	while (SensorValue(rearRightBumper) == 0 && SensorValue(rearLeftBumper) == 0) {
		checkLines();

		// Is a line dark?
		if (lState.leftLineDark || lState.rightLineDark || lState.middleLineDark) {
			// Left line is dark by itself.
			if (lState.leftLineDark && !lState.rightLineDark && !lState.middleLineDark) {
				while (lState.leftLineDark) {
					turn_right(10);
					checkLines();
				}
			}

			// Right line is dark by itself.
			if (!lState.leftLineDark && lState.rightLineDark && !lState.middleLineDark) {
				while (lState.rightLineDark) {
					turn_left(10);
					checkLines();
				}
			}

			// Middle line is dark by itself.
			if (!lState.leftLineDark && !lState.rightLineDark && lState.middleLineDark) {
				if (lState.lastMarker == left) {
					// Turn right until left goes off again. Then, go forward and left slightly.
					while (!lState.leftLineDark) {
						turn_right(10);
						checkLines();
					}
					move_forwards(20);
					turn_left(20);
				}
				else {
					// Turn left until right goes off again. Then, go forward and right slightly.
					while (!lState.rightLineDark) {
						turn_left(10);
						checkLines();
					}
					move_forwards(20);
					turn_right(20);
				}
			}

			// If any two or all three are dark
			if ((lState.leftLineDark && lState.rightLineDark) || (lState.leftLineDark && lState.middleLineDark) || (lState.middleLineDark && lState.rightLineDark)) {
				// Back up and turn away from the last marker.
			  move_backwards(40);
			  if (lState.lastMarker == left) {
			  	// Turn right a bit.
			    turn_right(40);
			  }
			  else {
			  	turn_left(40);
			  }
			}
		}

		move_forwards(10);
	}
}

// -------------------------------------------------
// END LINE TRACKING
// =================================================

// =================================================
// Control Arm
// -------------------------------------------------

void checkArm() {
	if (SensorValue(armLimit)) {
		// Force motor up.
		motor[armDrive] = maxPower;
		wait10MSec(5);
		
		// Set armDrive to something higher.
		angle = 10;
	}
	int degrees = SensorValue(armAngle);
	degrees = (degrees - min) / conversion;
	if (degrees < angle) {
		// Move motor up.
		if (degrees + minPowerThreshold < angle)
			motor[armDrive] = maxPower;
		else motor[armDrive] = minPower;
	}
	else if (degrees > angle) {
		// Move motor down.
		motor[armDrive] = -minPower;
	}
	else {
		// Turn motor off
		motor[armDrive] = 0;
	}
}

void setArm(int degrees) {
	angle = degrees;
	checkArm();
}

// -------------------------------------------------
// END CONTROL ARM
// =================================================



// =================================================
// STATE MANAGER
// -------------------------------------------------

void checkState() {
	// Check arm state.
	checkArm();
}

// 

// -------------------------------------------------
// END STATE MANAGER
// =================================================

// =================================================
// GRID
// -------------------------------------------------

void setBlockState(int x, int y, blockState state) {
	if (x < gridWidth && y < gridHeight) {
		grid[x][y] = state;
	}
}

void setBlockState_range(int xIncrement, int yIncrement, int startX, int startY, int distanceClear) {
	for (int x = 0; x < 10; x++) {
		startX += xIncrement;
		startY += yIncrement;
		
		if (x < distanceClear) {
			setBlockState(startX, startY, clear);
		}
		else if (x == distanceClear) {
			setBlockState(startX, startY, blocked);
		}
		else {
			setBlockState(startX, startY, unknown);
		}
	}
}

void sensorMapCheck(int sensorValue, int cangle) {
	// Update 10 blocks in front.
	// If 0, modify all x values to the right.
	if (cangle == 0) {
		setBlockState_range(1, 0, Me.position.x, Me.y, frontClearance);
	}
	else if (cangle == 90) {
		setBlockState_range(0, 1, Me.position.x, Me.y, frontClearance);
	}
	else if (cangle == 180) {
		setBlockState_range(-1, 0, Me.position.x, Me.y, frontClearance);
	}
	else if (cangle == 270) {
		setBlockState_range(0, -1, Me.position.x, Me.y, frontClearance);
	}
}

void checkMap() {
	sensorMapCheck(SensorValue(sonarFront), angle);
	sensorMapCheck(SensorValue(sonarLeft), angle + 90 % 360);
	sensorMapCheck(SensorValue(sonarRight), abs(angle - 90) % 360);
}

int blockClearance(int distance) {
	if (distance <= 0) return 10;
	int result = distance / 12;
	if (distance > 10) return 10;
	return result;
}

// -------------------------------------------------
// END GRID
// =================================================

// =================================================
// PATH PLANNING
// -------------------------------------------------
int distanceToGoal(int x, int y) {
	return distance(x, y, Me.goal.x, Me.goal.y);
}

int distance(int x, int y, int x2, int y2) {
	return sqrt(x2  x + y2- y);
}

void findRoute() {
	int closedNodeIndex = 0;
	int openNodeIndex = 0;
	int openNodeCount = 1;
	cell current;
	
	cell closedNode[gridWidth * gridHeight];
	cell openNode[gridWidth * gridHeight];
	cell cameFrom[gridWidth][gridHeight];
	
	openNode[openNodeIndex++] = Me.position;
	int gscores[gridWidth][gridHeight];
	gscores[Me.position.x][Me.position.y] = 0;
	
	int fscores[gridWidth][gridHeight];
	fscores[Me.position.x][Me.position.y] = distanceToGoal(Me.position.x, Me.position.y);
	
	while (openNodeCount > 0) {
		for (int x = 0; x < openNodeIndex) {
			// Get current node with lowest score.
			if (fscores[openNode[x].x][openNode[x].y] != NULL && 
				fscores[openNode[x].x][openNode[x].y] < fscores[current.x][current.y]) {
				current.x = openNode[x].x;
				current.y = openNode[x].y;
			}
			
			if (current.x == Me.goal.x && current.y == Me.goal.y) {
				return navigatedNodes;
			}
			
			// Remove current from open nodes.
			for (int i = 0; i < openNodeIndex; i++) {
				if (openNode[i] != NULL && openNode[i].x == current.x && openNode[i].y == current.y) {
					openNode[i] = NULL;
				}
			}
			// Add to closed nodes.
			closedNode[closedNodeIndex++] = current;
			
			cell neighbor;
			int ngscore = 0;
			int nfscore = 0;
			
			for (int neighbors = 0; neighbors < 4; neighbors++) {
				if (neighbors == 0) {
					neighbor.x = current.x + 1;
					neighbor.y = current.y;
				}
				else if (neighbors == 1) {
					neighbor.x = current.x;
					neighbor.y = current.y + 1;
				}
				else if (neighbors == 2) {
					neighbor.x = current.x - 1;
					neighbor.y = current.y;
				}
				else if (neighbors == 3) {
					neighbor.x = current.x;
					neighbor.y = current.y - 1;
				}
				
				// Make sure neighbor is in range.
				if (neighbor.x < 0 || neighbor.x >= gridWidth || neighbor.y < 0 || neighbor.y >= gridHeight) {
					continue;
				}
				
				ngscore = gscores[current.x][current.y] + distance(current.x, current.y, neighbor.x, neighbor.y);
				nfscore = ngscore + distanceToGoal(neighbor.x, neighbor.y);
				
				// Check if neighbor is in closed set.
				bool closedSet = false;
				bool openSet = false;
				int limit = closedNodeIndex;
				if (openNodeIndex > limit) limit = openNodeIndex;
				
				for (int n = 0; n < limit; n++) {
					if (closedNode[n] != NULL) {
					 	if (closedNode[n].x == neighbor.x && closedNode[n].y == neighbor.y) {
							closedSet = true;
						}
					}
					if (openNode[n] != NULL) {
						if (openNode[n].x == neighbor.x && openNode[n].y == neighbor.y) {
							openSet = true;
						}
					}
					
				}
				
				if (closedSet && nfscore >= fscores[neighbor.x][neighbor.y]) {
					continue;
				}
				
				if (!openSet || (fscores[neighbor.x][neighbor.y] != NULL && nfscore < fscores[neighbor.x][neighbor.y])) {
					cameFrom[neighbor.x][neighbor.y] = current;
					gscores[neighbor.x][neighbor.y] = ngscore;
					fscores[neighbor.x][neighbor.y] = nfscore;
					
					if (!openSet) {
						openNode[openNodeIndex++] = neighbor;
					}
				}
			}
			
		}
	}
	
	
}

// -------------------------------------------------
// END PATH PLANNING
// =================================================


void initGrid() {
	for (int x = 0; x < 10; x++) {
		for (int y = 0; y < 10; y++) {
			grid[x][y] = unknown;
		}
	}
}

task main()
{
	// Set the current goal.
	cell goal;
	goal.x = 5;
	goal.y = 5;
	
	// Initialize Myself
	Me.position.x = 0;
	Me.position.y = 0;
	Me.direction = 0;
	Me.goal = goal;
	
	// Initialize our current map.
	checkMap();
	
	// Determine a route.
	findRoute();
	
	//turn_left_angle(90);
	/*
	// Initialize the working grid.
	initGrid();
	
	// Put the arm in observer position.
	setArm(25);
	wait10Msec(5);
	
	// Set sonar to look straight ahead.
	lookForward();
	*/
	// Orientate to goal
	
	
	/*nMotorEncoder[rightDrive] = 0;
	
	
	int amount = nMotorEncoder[rightDrive];
	while (amount < 500) {
		motor[leftDrive] = 50;
		motor[rightDrive] = 50;
		wait1MSec(1);
		amount = nMotorEncoder[rightDrive];
	}
	
	return;
	
	
	setArm(25);
	wait10Msec(5);
	lookForward();

	while (true) 
	{
		// Calls to lineTracker() don't have any effect if there is no line present.
		lineTracker();

		// Check ultrasonic distance.
		
		
	}*/
	
	
}
